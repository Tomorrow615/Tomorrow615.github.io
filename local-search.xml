<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>随笔11-3</title>
    <link href="/2024/11/22/%E9%9A%8F%E7%AC%9411-3/"/>
    <url>/2024/11/22/%E9%9A%8F%E7%AC%9411-3/</url>
    
    <content type="html"><![CDATA[<p>​刚突然意识到自己现在好闲。现在是周五的晚上，之前这个时候都在忙什么呢，上周是在deP5的bug，在之前可能是准备数竟，或者写OO作业吧。</p><p>​这个星期其实就感觉节奏慢下来了，一方面是没了OO作业，再一个计组后面好像就俩P了，总给我一种马上结束已经功成名就的感觉。虽然P7好像事儿很多来着，但毕竟我挂了一次没跟上所以当下的事儿也轻松些。所以说到底，只是眼前没那么多ddl（其实事儿很多），也没有什么很重要的考试给我紧张感了。</p><p>​现在仿佛是适应了整个的环境和节奏，还记得一个月前的某个晚上我好像很认真地在思考转专业的事儿，但现在基本上没这个念头了，感觉过得好像也还行，所以说嘛，很多事儿经历了之后也就那样，没什么大不了的。</p><p>​感觉现在文字能力退化不少，打个字都觉得念不顺，反正想主要记录一下现在的心境和打算吧。想的什么和安排的什么确实是有区别，一个是天马行空各种试探性的念头，一个是切切实实马上就要落地的计划。长远看当然前者很需要有，而且你的行动都必须落在你长远打算的蓝图下正确的路径上，但这其实很难。没有那么多资源，只凭借你自己看到的听到的，怎么可能很完美地勾勒出你大学毕业后的样子？特别是我现在成绩也没那么拔尖，要真的第一第二那也不用想各种路就是。</p><p>​保研考研出国工作，大概好像是这么多。但保研是保哪儿的研，特别是自己很不想在一个地方待很久，所以头更大；考研又都说风险高，自己也有点怕就是，但没准赌对了就赢了；出国看起来到不错，一来能避开国内病态的卷的氛围，二来也能自己去探索发展，但问题也多，一是一年硕国内认可度可能确实不太行，二来有点小贵也不知道值不值当（从长远看），三来申报的流程什么的又好复杂，四是自己也没准适应不了，但主要可能是前三个问题吧，这里面道道更多；工作暂且先不说吧，反正外界环境给我的理念和我自己的理念都告诉我，只有个本科学历确实不行，当然工作还包括考公选调什么的，这这这应该是我从小嗤之以鼻的。</p><p>​鬼知道前面那些我想过多少遍，其实有点无用功，毕竟自己也想不出个所以然，干脆寒暑假再说吧，现在想是真的只有内耗。然后就是说安排的计划，大概就是些很明确的现阶段应该干的正确的事儿吧。发现有个很好玩的事情，人们总倾向于去来回纠结未来很远的事儿，仿佛那些是能决定他们人生的，而忽略了眼下我们日常生活中的很多小事，比如现在是打一晚上游戏还是说看一晚上概统，但后者明明是更好抉择的，而且是显而易见有强占优策略的。没准别想那么多，就一步步正常的走，就可能走到你想去的任何地方。</p><p>​自己挺喜欢听陈奕迅的歌，但《任我行》到还没有坐那儿好好欣赏过。今天听罢确实有很深的感触，和之前听《陀飞轮》差不多，有一种自己文学功底不好但却全在歌词里面唱出来的爽感，那也就以几句印象很深的歌词收尾吧。</p><blockquote><p>从何时你也学会不要离群</p><p>从何时发觉没有同伴不行</p><p>从何时惋惜蝴蝶困于那桃源</p><p>飞多远有谁会对它操心</p><p>曾迷途才怕追不上满街赶路人</p><p>无人理睬如何求生</p></blockquote><blockquote><p>从何时开始忌讳空山无人</p><p>从何时开始怕遥望星尘</p></blockquote><blockquote><p>人群是那么像羊群</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>随笔11-2</title>
    <link href="/2024/11/10/%E9%9A%8F%E7%AC%9411-2/"/>
    <url>/2024/11/10/%E9%9A%8F%E7%AC%9411-2/</url>
    
    <content type="html"><![CDATA[<p>​昨天11.9算是能让自己记住的一天，至少一天过下来很充实。上午考了数竞，虽然有插曲吧但还是挺顺利，下午听物理讲座，晚上去看个电影吃个夜宵再极限骑车回来。</p><p>​其实现在最大问题是感觉太多琐事剥夺了深度思考的时间，大脑慢慢变得麻痹，而麻痹的大脑让处境变得更加恶化。其实无论什么考试，考试的那段时间我是挺珍惜的，毕竟是大学为数不多能坐在那儿不去看手机一直思考的时间（当然抛开结果先不谈）。所以就算是每周上机考，那两个小时的煎熬也让大脑变得活跃起来，高效率的思考会给人一种充实的感觉。</p><p>​有时我就在想，其实现在要说学的时间，我也真不少，但为啥天天就感觉差点意思，也打不起精神呢？究其原因是自己厌倦了低效率的状态，自己也知道很多时候做的可以说是无用功，是一种在高中我会嗤之以鼻的状态，但现在我却不断重复。我也想不起来太多我曾在何时效率很高地完成过一件事（近点儿可能就竞赛考试前晚上差不多一个小时做了点儿题？），大多都是看会儿这写会儿那，这效率自然不必多说。</p><p>​其实说到底，就一句“该学学该玩玩”，只是觉得大学这竟成了奢望，发发牢骚罢了。这个星期过得好像也相对轻松，至少自己没那么感到ex厌倦（因为我不用写co课下）。所以空出来的很多时间会看点儿竞赛什么的，虽然现在看来基本上没啥章程完全瞎搞，但毕竟是自己感兴趣的东西，花时间也是开心的。</p><p>​数学竞赛答案也对了，但不想在这儿多说，等结果出来在吧）。反正感觉自己可能是考试考少了？遇到考试很难有我所希望的考试的感觉，或者进入不了状态这样，感觉跟平时零散的安排的有关系。</p><p>​晚上吃夜宵也和高中同学聊了好久，确实现在过得很压抑，各种制度感觉都不是为自己设计的，试图把我扭曲。什么东西也放不下，齐手抓也抓不完，便这样内耗着。现在感觉脑子不是很清醒，但大概明确的是每天尽量让自己过得充实一点吧，有闲的时间在自己好好思考一下未来的路，祝好。</p><blockquote><p>拖延的最大坏处还不是耽误，而是会使自己变得犹豫，甚至丧失信心。不管什么事，决定了，就立刻去做，这本身就能使人生气勃勃，保持一种主动和快乐的心情。——史铁生</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>随笔11-1</title>
    <link href="/2024/11/05/%E9%9A%8F%E7%AC%9411-1/"/>
    <url>/2024/11/05/%E9%9A%8F%E7%AC%9411-1/</url>
    
    <content type="html"><![CDATA[<p>既然说要写，那就简单写点什么吧，如果看到了当个乐子也好。</p><p>昨晚上<code>CO</code>上机，当然算是惨不忍睹。报的错不知道是课上问题还是课下问题，遂两者兼顾；三个题每个题都几个点不过所以都不想扔掉，遂三线并行。于是在多核运转下，一个题都没过…</p><p>下来还觉得可能是课下问题，有<code>bug</code>没<code>de</code>出来，所以情有可原（有点孔乙己的味道了）。但回来测了半天好像发现还真就没问题，那难不成还真就我课上觉得显而易见不需要思考的几行代码错了？</p><p>emm至少第一题还真是，最开始的报错是后16位错，也就说是负数取模问题，于是我便改了。然而，再次提交后却发现是前面16位错，而且错误结果是<code>0X0001</code>（应该是<code>0x1111</code>）。如果在正常情境下（或者是课下自己做），肯定会发现是前面位拼接有问题，但考试我就根本没往这儿想，老想着是不是课下有啥问题导致的，因为我的潜意识里面第一次交前16位是对的所以不会是简单的位拼接错，interesting。</p><p>所以是怎么发现的呢，因为晚上躺半天睡不着遂起来微信吐槽，结果刚把自己觉得离谱的错误说出去，对方就问位拼接是不是写的<code>&#123;&#123;16&#123;1'b1&#125;&#125; temp&#125;</code>，结果我猛然惊醒，自己写的是<code>&#123;16&#39;b1 temp&#125;</code>。。。</p><hr><p>至于后面俩题，我姑且也认为是各种花里胡哨的语法问题导致的吧，虽然很难接受但大概率就是这样。还记得上次P1挂掉，其实也是<code>verilog</code>的基础语法问题，只能说没引起重视（虽然没有破罐子破摔的意思，但可能没啥行动？）</p><p>有别的发现到时候再更吧</p><p>然后这个博客打算就当做自己闲来无事输出东西的一种爱好，也不打算刻意去打造整体排版什么的（以后想起来可能会加点儿<code>comment</code>或者特效什么的，但看样子我是没啥太闲的时间）。毕竟写点儿东西一是至少让自己感受一下脑子动起来的感觉，二来日后也可以当个消遣看看。那先就这样，b事儿还有很多咧。</p>]]></content>
    
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OO_Pre</title>
    <link href="/2024/11/05/OO-Pre/"/>
    <url>/2024/11/05/OO-Pre/</url>
    
    <content type="html"><![CDATA[<blockquote><p>这个是oopre课上的最后一次作业，要求写一个博客，所以既然写好了就放上来吧</p></blockquote><h2 id="Part1-架构设计"><a href="#Part1-架构设计" class="headerlink" title="Part1-架构设计"></a>Part1-架构设计</h2><p>最终架构如下图所示，主要分为以下几方面：</p><p><img src="/../img/oopre1.png" alt="oopre1"></p><ol><li><p><code>Adventure</code>：管理核心内容和核心方法，定义<code>bottles</code>、 <code>equipments</code>、 <code>backpack</code>、<code>fragments</code>等容器便于冒险者本人相关操作。</p></li><li><p><code>Bottle</code>：定义为抽象类，通过继承重写的方法实现三个子类，即<code>HpBottle</code>、<code>AtkBottle</code>、<code>DefBottle</code>。同时附上<code>BottleFactory</code>类实现工厂模式，更为清晰地实现创建过程。</p></li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BottleFactory</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Bottle <span class="hljs-title function_">createBottle</span><span class="hljs-params">(...)</span> &#123;<br>        Bottle bottle;<br>        <span class="hljs-keyword">switch</span> (type) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;HpBottle&quot;</span>:<br>                bottle = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HpBottle</span>();<br>                <span class="hljs-keyword">break</span>;<br>            ...<br>        &#125;<br>        ...<br>        <span class="hljs-keyword">return</span> bottle;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li><p><code>Equipment</code>：定义为抽象类，通过继承重写的方法实现三个子类，即<code>Axe</code>、<code>Blade</code>、<code>Sword</code>。同时附上<code>EquipmentFactory</code>类实现工厂模式，形式与<code>BottleFactory</code>相近。</p></li><li><p><code>Fragment</code>、<code>Backpack</code>：定义各自基本的属性和操作方法，方便<code>Adventure</code>类管理实现。</p></li><li><p><code>EmploymentManager</code>：管理冒险者的雇佣关系，实现<code>get</code>、<code>hire</code>等操作。</p></li><li><p><code>Battle</code>：单独负责<strong>case10</strong>战斗里面的相关操作，降低主函数的复杂性。</p></li><li><p><code>Guard</code>、<code>Treasure</code>等：实现秘境探险相关操作，通过<strong>“实现接口”“工厂模式“</strong>等清晰管理相关任务。</p></li><li><p><code>Main</code>：负责<strong>IO</strong>处理，以及指定操作的方法调用。</p></li></ol><h2 id="Part2-架构调整"><a href="#Part2-架构调整" class="headerlink" title="Part2-架构调整"></a>Part2-架构调整</h2><p>整体的架构变化，主要可分为两方面</p><ol><li><p><strong>对原有架构的修改</strong>：把之前写好的推倒重来，但为了方便后面的操作。</p><ul><li>第二次迭代中（hw_3）考虑到许多操作都是针对<code>id</code>这个属性，于是用<code>HashMap</code>替代了之前的<code>ArrayList</code>（也就是将<code>bottles</code>、<code>equipments</code>等三个容器都统一定义为<code>HashMap</code>），用<code>id</code>作key，更加简洁高效。</li><li>第三次迭代中（hw_5）考虑到<code>bottle</code>、<code>equipment</code>的复杂性，于是用<code>Factory</code>的方式来创建管理，抛弃原有复杂的创建过程，更加直观明了。</li></ul></li><li><p><strong>添加新内容</strong>：为了实现新的需求，在原有基础上定义新内容新操作等。</p><ul><li><p>为实现<u>战斗</u>操作，定义<code>Battle</code>类，实现“判断能不能战斗成功”“若成功相应冒险者属性怎么改变”等问题。</p></li><li><p>为刻画<u>雇佣</u>关系，定义<code>EmploymentManager</code>类，通过<code>id</code>指向的方式，在保证<code>Adventure</code>类不变的情况下，简单高效地刻画了雇佣关系。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EmploymentManager</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;Integer, List&lt;Integer&gt;&gt; employments = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;Integer, Map&lt;Integer, Integer&gt;&gt; helpCounts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    ...<br></code></pre></td></tr></table></figure></li><li><p>为实现<u>探险</u>任务，定义了<code>Guard</code>、<code>Treasure</code>接口以及相关的类，上层只需简单地调用。</p></li></ul></li></ol><h2 id="Part3-使用JUnit的心得体会"><a href="#Part3-使用JUnit的心得体会" class="headerlink" title="Part3-使用JUnit的心得体会"></a>Part3-使用JUnit的心得体会</h2><ol><li>首先应该理解这么做是为什么，毕竟项目大了之后排查bug会很困难。如果我们真正做好了相关的测试，把每一个类的每一个操作的各个分支都测试过，再出现bug的概率当然会小很多。</li><li>其次就是出现问题之后，要学会通过单元测试来自我排查。比如发现是战斗的时候出现了RE的情况，就可以自己构造雇佣关系等样例来进行战斗测试，帮助自己排查出错误。（比如我发现是因为循环的时候删除了东西）</li><li>最后就是更高阶的，自己构造一些边缘复杂的强测来考验自己的代码，学会自己构造数据也是一种能力。</li></ol><h2 id="Part4-学习OOPre的心得体会"><a href="#Part4-学习OOPre的心得体会" class="headerlink" title="Part4-学习OOPre的心得体会"></a>Part4-学习OOPre的心得体会</h2><p>简单点说，这种面向对象的开发方式非常适合大的项目。这种方式将一个大的问题层次化，而你只需要着眼于你现在实现的小任务，最后上层进行统一的管理调用即可。</p><p>再说一下debug的心得：</p><ul><li>第一种是写代码的时候那一瞬间走神了，然后本该调用A类里面的查找错写成了B类里面的查找，最后强测就会挂很多。当然，这种debug的时候通读一遍还是很容易发现。</li><li>第二种就是有些操作其实并没有实现你真正想要实现的操作，比如删除某个东西的时候，以为直接调用<code>backpack</code>的<code>remove</code>方法就行了，但实际上这只能把背包里面的东西删掉，实际拥有的东西并没有删掉。这种就需要最开始写代码的时候认真思考，要不然debug会要很长时间。</li><li>还有可能就是做好草稿，至少别忘了自己写了什么为什么要写，东西多的时候很容易忘记。</li></ul><h2 id="Part5-课程建议"><a href="#Part5-课程建议" class="headerlink" title="Part5-课程建议"></a>Part5-课程建议</h2><p>课程刚开始对java了解太少了，所以畏手畏脚的。希望以后最开始可以先讲讲很基础的知识，或者知道各个类是怎么联合实现功能的。</p>]]></content>
    
    
    
    <tags>
      
      <tag>课程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>电脑杂症</title>
    <link href="/2024/09/28/%E7%94%B5%E8%84%91%E6%9D%82%E7%97%87/"/>
    <url>/2024/09/28/%E7%94%B5%E8%84%91%E6%9D%82%E7%97%87/</url>
    
    <content type="html"><![CDATA[<h2 id="一-电脑无WiFi标"><a href="#一-电脑无WiFi标" class="headerlink" title="一. 电脑无WiFi标"></a>一. 电脑无WiFi标</h2><h3 id="情况："><a href="#情况：" class="headerlink" title="情况："></a>情况：</h3><ol><li>装有虚拟机；</li><li>计算机管理—设备管理器—网路适配器—WiFi有黄色感叹号，双击里面显示设备状态出现错误代码56。</li></ol><h3 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h3><ol><li><p>win+r 输入regedit，进入<strong>注册表</strong>；</p></li><li><p>删除HKEY_CLASSES_ROOT\CLSID\{3d09c&#x2F;ca-2bcc-4067-b9bb-3f3ec&#x2F;43a87b}。</p><blockquote><p>[!NOTE]</p><p><strong>CLISID</strong>是“C”开头，要翻到最下面找到。</p></blockquote></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CO Pre</title>
    <link href="/2024/09/23/CO-Pre/"/>
    <url>/2024/09/23/CO-Pre/</url>
    
    <content type="html"><![CDATA[<h1 id="verilog"><a href="#verilog" class="headerlink" title="verilog"></a>verilog</h1><h3 id="1-always块"><a href="#1-always块" class="headerlink" title="1.always块"></a>1.always块</h3><p>在 Verilog 中，<code>if</code>、<code>for</code>、<code>case</code> 等控制语句必须放在 <code>always</code> 块中，因为它们涉及到时序或组合逻辑的条件判断与循环。</p><ol><li>**<code>if</code>**：用于条件判断。</li><li>**<code>for</code>**：用于循环。</li><li>**<code>case</code>**：用于多分支选择。</li></ol><p>这些语句需要在 <code>always</code> 块内，以确保合成工具能够正确处理逻辑行为。简单的赋值语句和 <code>assign</code> 可以在模块的顶层直接使用。</p><h3 id="2-变量的初始化"><a href="#2-变量的初始化" class="headerlink" title="2.变量的初始化"></a>2.变量的初始化</h3><p>在 Verilog 中，<strong>变量的初始化</strong>和更新操作有严格的规则。特别是，Verilog 不允许直接在模块体内初始化变量值，这与传统编程语言有所不同。你提到的句子描述了 Verilog 处理变量初始化的两种合法方式：<code>initial</code> 块和由时钟驱动的 <code>always</code> 块。下面我将详细解释这句话的含义。</p><ol><li><strong>模块体内不能直接初始化变量</strong></li></ol><p>在 Verilog 中，模块内部的寄存器（<code>reg</code>）或其他数据类型不能像软件编程语言那样在声明时直接赋初值。举个例子，在 C 语言中你可以写：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>但是在 Verilog 模块体内，不能像这样：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> my_module;<br>    <span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] my_var = <span class="hljs-number">32&#x27;b0</span>;  <span class="hljs-comment">// 这种写法是非法的</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>这条规则是因为 Verilog 是硬件描述语言，而硬件电路的行为依赖于时钟和其他信号的变化。直接初始化寄存器会与硬件设计的本质相冲突，因此 Verilog 不允许在模块体内直接赋初值。</p><ol start="2"><li><strong>初始化操作应在 <code>initial</code> 块中完成</strong></li></ol><p>如果想给变量赋初始值，可以使用 <code>initial</code> 块来完成。<code>initial</code> 块只在仿真时运行一次，通常用于在仿真开始时对寄存器或变量进行初始化。<code>initial</code> 块不会综合到实际的硬件中，它仅用于仿真。</p><p>示例：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> my_module;<br>    <span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] my_var;<br>    <br>    <span class="hljs-comment">// initial 块用于初始化变量</span><br>    <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>        my_var = <span class="hljs-number">32&#x27;b0</span>;  <span class="hljs-comment">// 仿真时变量在开始时被初始化</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>my_var</code> 在仿真时会被初始化为 <code>32&#39;b0</code>。注意，<code>initial</code> 块只执行一次，适用于仿真，而不是实际硬件电路中。</p><ol start="3"><li><strong>使用时钟驱动的 <code>always</code> 块来更新变量</strong></li></ol><p>如果你需要在综合时对变量进行控制和更新，通常是在时钟边沿（如时钟的上升沿或下降沿）发生时，通过 <strong>时钟驱动的 <code>always</code> 块</strong> 来实现。这种 <code>always</code> 块会在每个时钟周期进行状态更新，寄存器的值会根据时钟信号变化。</p><p>示例：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> my_module (<br>    <span class="hljs-keyword">input</span> clk,<br>    <span class="hljs-keyword">input</span> reset,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] my_var<br>);<br>    <span class="hljs-comment">// 使用时钟信号控制的 always 块</span><br>    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> reset) <span class="hljs-keyword">begin</span><br>        <span class="hljs-keyword">if</span> (reset)<br>            my_var &lt;= <span class="hljs-number">32&#x27;b0</span>;  <span class="hljs-comment">// 当 reset 信号为高时，my_var 复位</span><br>        <span class="hljs-keyword">else</span><br>            my_var &lt;= my_var + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 否则每个时钟周期 my_var 增加 1</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>my_var</code> 会根据时钟信号进行更新。如果 <code>reset</code> 信号被拉高，<code>my_var</code> 会被重置为 <code>32&#39;b0</code>。这种机制会被综合为硬件电路中的触发器（Flip-Flop）。</p><ol start="4"><li><strong>为什么不能直接初始化？</strong></li></ol><p>硬件设计中，电路的行为并不是立即生效的，它依赖时钟信号来驱动状态变化。直接初始化变量在硬件中没有对应的物理实现，而时钟驱动的 <code>always</code> 块或仿真中使用的 <code>initial</code> 块才能准确描述硬件电路的行为。</p><p>在综合时，硬件描述语言会转换为实际的硬件电路，直接初始化的赋值没有明确的时间依赖性，因此不能综合为逻辑电路。硬件电路需要在一个明确的时序框架内（如时钟驱动）进行数据更新和状态保持，这正是 <code>always @(posedge clk)</code> 的作用。</p><ol start="5"><li><strong>总结</strong></li></ol><ul><li><strong>模块体内不能直接初始化变量</strong>，因为硬件电路没有类似软件中的立即赋值行为。</li><li><strong><code>initial</code> 块</strong> 只能在仿真时使用，提供一次性的初始化操作，但它不会综合为实际硬件。</li><li><strong>时钟驱动的 <code>always</code> 块</strong> 用于描述硬件的状态更新，它能够根据时钟信号进行有序的变量更新，并可以被综合为硬件电路。</li></ul><p>希望这个解释能帮助你理解为什么 Verilog 不能在模块体内直接初始化变量，以及应该如何正确初始化和更新寄存器或变量。</p><h3 id="3-其他"><a href="#3-其他" class="headerlink" title="3.其他"></a>3.其他</h3><ul><li><p><code>always @(*)</code> 组合逻辑里面不要有</p>  <figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog">i = i + <span class="hljs-number">1</span>;<br>tem = tem + a[i] * b[i];<br></code></pre></td></tr></table></figure></li></ul><p>​会多次累加，导致逻辑错误。</p><ul><li><p><code>reg</code> 类型的信号必须在 <code>always</code> 块中进行赋值，而不能通过 <code>assign</code> 语句进行驱动。</p><p>  <code>assign</code> 语句通常用于连续赋值，即用于 <code>wire</code> 类型信号，通常用于组合逻辑。而 <code>reg</code> 信号则用于存储状态，应该由 <code>always</code> 块控制。</p></li><li><p>不要<code>&#123; &#125;</code>，要用<code>begin end</code> ！！！</p></li><li><p>粘个原码</p>  <figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> dot_product (<br>    <span class="hljs-keyword">input</span>  [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] a,<br>    <span class="hljs-keyword">input</span>  [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] b,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">5</span>:<span class="hljs-number">0</span>] result<br>);<br>    <span class="hljs-keyword">integer</span> i;<br>    <span class="hljs-keyword">reg</span> [<span class="hljs-number">5</span>:<span class="hljs-number">0</span>] temp;<br><br>    <span class="hljs-keyword">always</span> @(*) <span class="hljs-keyword">begin</span><br>        temp = <span class="hljs-number">0</span>; <br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i = i + <span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span><br>            temp = temp + (a[i] * b[i]);<br>        <span class="hljs-keyword">end</span><br>        result = temp;<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br><br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>CO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于博客</title>
    <link href="/2024/07/29/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2/"/>
    <url>/2024/07/29/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="关于博客"><a href="#关于博客" class="headerlink" title="关于博客"></a>关于博客</h1><h2 id="1-一些命令"><a href="#1-一些命令" class="headerlink" title="1.一些命令"></a>1.一些命令</h2><ul><li><p>创建</p>  <figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">hexo <span class="hljs-built_in">new</span> <span class="hljs-string">&quot;name&quot;</span>  <br>hexo <span class="hljs-built_in">new</span> <span class="hljs-built_in">post</span> <span class="hljs-string">&quot;post name&quot;</span><br>hexo <span class="hljs-built_in">new</span> page <span class="hljs-string">&quot;page name&quot;</span><br>hexo <span class="hljs-built_in">new</span> draft <span class="hljs-string">&quot;draft name&quot;</span><br>hexo publish <span class="hljs-string">&quot;post name&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>清理缓存</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo cl<br></code></pre></td></tr></table></figure></li><li><p>生成静态文件</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo g<br></code></pre></td></tr></table></figure></li><li><p>本地调试</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo s<br></code></pre></td></tr></table></figure></li><li><p>部署博客</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo d<br></code></pre></td></tr></table></figure></li><li><p>一键部署</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo cl &amp;&amp; hexo g &amp;&amp; hexo d<br></code></pre></td></tr></table></figure></li></ul><h2 id="2-主题"><a href="#2-主题" class="headerlink" title="2.主题"></a>2.主题</h2><p><a href="https://hexo.fluid-dev.com/docs/start/"> Hexo Fluid 用户手册 </a></p>]]></content>
    
    
    
    <tags>
      
      <tag>blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/07/21/hello-world/"/>
    <url>/2024/07/21/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
