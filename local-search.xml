<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>CO Pre</title>
    <link href="/2024/09/23/CO-Pre/"/>
    <url>/2024/09/23/CO-Pre/</url>
    
    <content type="html"><![CDATA[<h1 id="verilog"><a href="#verilog" class="headerlink" title="verilog"></a>verilog</h1><h3 id="1-always块"><a href="#1-always块" class="headerlink" title="1.always块"></a>1.always块</h3><p>在 Verilog 中，<code>if</code>、<code>for</code>、<code>case</code> 等控制语句必须放在 <code>always</code> 块中，因为它们涉及到时序或组合逻辑的条件判断与循环。</p><ol><li>**<code>if</code>**：用于条件判断。</li><li>**<code>for</code>**：用于循环。</li><li>**<code>case</code>**：用于多分支选择。</li></ol><p>这些语句需要在 <code>always</code> 块内，以确保合成工具能够正确处理逻辑行为。简单的赋值语句和 <code>assign</code> 可以在模块的顶层直接使用。</p><h3 id="2-变量的初始化"><a href="#2-变量的初始化" class="headerlink" title="2.变量的初始化"></a>2.变量的初始化</h3><p>在 Verilog 中，<strong>变量的初始化</strong>和更新操作有严格的规则。特别是，Verilog 不允许直接在模块体内初始化变量值，这与传统编程语言有所不同。你提到的句子描述了 Verilog 处理变量初始化的两种合法方式：<code>initial</code> 块和由时钟驱动的 <code>always</code> 块。下面我将详细解释这句话的含义。</p><ol><li><strong>模块体内不能直接初始化变量</strong></li></ol><p>在 Verilog 中，模块内部的寄存器（<code>reg</code>）或其他数据类型不能像软件编程语言那样在声明时直接赋初值。举个例子，在 C 语言中你可以写：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>但是在 Verilog 模块体内，不能像这样：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> my_module;<br>    <span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] my_var = <span class="hljs-number">32&#x27;b0</span>;  <span class="hljs-comment">// 这种写法是非法的</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>这条规则是因为 Verilog 是硬件描述语言，而硬件电路的行为依赖于时钟和其他信号的变化。直接初始化寄存器会与硬件设计的本质相冲突，因此 Verilog 不允许在模块体内直接赋初值。</p><ol start="2"><li><strong>初始化操作应在 <code>initial</code> 块中完成</strong></li></ol><p>如果你想给变量赋初始值，可以使用 <code>initial</code> 块来完成。<code>initial</code> 块只在仿真时运行一次，通常用于在仿真开始时对寄存器或变量进行初始化。<code>initial</code> 块不会综合到实际的硬件中，它仅用于仿真。</p><p>示例：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> my_module;<br>    <span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] my_var;<br>    <br>    <span class="hljs-comment">// initial 块用于初始化变量</span><br>    <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>        my_var = <span class="hljs-number">32&#x27;b0</span>;  <span class="hljs-comment">// 仿真时变量在开始时被初始化</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>my_var</code> 在仿真时会被初始化为 <code>32&#39;b0</code>。注意，<code>initial</code> 块只执行一次，适用于仿真，而不是实际硬件电路中。</p><ol start="3"><li><strong>使用时钟驱动的 <code>always</code> 块来更新变量</strong></li></ol><p>如果你需要在综合时对变量进行控制和更新，通常是在时钟边沿（如时钟的上升沿或下降沿）发生时，通过 <strong>时钟驱动的 <code>always</code> 块</strong> 来实现。这种 <code>always</code> 块会在每个时钟周期进行状态更新，寄存器的值会根据时钟信号变化。</p><p>示例：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> my_module (<br>    <span class="hljs-keyword">input</span> clk,<br>    <span class="hljs-keyword">input</span> reset,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] my_var<br>);<br>    <span class="hljs-comment">// 使用时钟信号控制的 always 块</span><br>    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> reset) <span class="hljs-keyword">begin</span><br>        <span class="hljs-keyword">if</span> (reset)<br>            my_var &lt;= <span class="hljs-number">32&#x27;b0</span>;  <span class="hljs-comment">// 当 reset 信号为高时，my_var 复位</span><br>        <span class="hljs-keyword">else</span><br>            my_var &lt;= my_var + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 否则每个时钟周期 my_var 增加 1</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>my_var</code> 会根据时钟信号进行更新。如果 <code>reset</code> 信号被拉高，<code>my_var</code> 会被重置为 <code>32&#39;b0</code>。这种机制会被综合为硬件电路中的触发器（Flip-Flop）。</p><ol start="4"><li><strong>为什么不能直接初始化？</strong></li></ol><p>硬件设计中，电路的行为并不是立即生效的，它依赖时钟信号来驱动状态变化。直接初始化变量在硬件中没有对应的物理实现，而时钟驱动的 <code>always</code> 块或仿真中使用的 <code>initial</code> 块才能准确描述硬件电路的行为。</p><p>在综合时，硬件描述语言会转换为实际的硬件电路，直接初始化的赋值没有明确的时间依赖性，因此不能综合为逻辑电路。硬件电路需要在一个明确的时序框架内（如时钟驱动）进行数据更新和状态保持，这正是 <code>always @(posedge clk)</code> 的作用。</p><ol start="5"><li><strong>总结</strong></li></ol><ul><li><strong>模块体内不能直接初始化变量</strong>，因为硬件电路没有类似软件中的立即赋值行为。</li><li><strong><code>initial</code> 块</strong> 只能在仿真时使用，提供一次性的初始化操作，但它不会综合为实际硬件。</li><li><strong>时钟驱动的 <code>always</code> 块</strong> 用于描述硬件的状态更新，它能够根据时钟信号进行有序的变量更新，并可以被综合为硬件电路。</li></ul><p>希望这个解释能帮助你理解为什么 Verilog 不能在模块体内直接初始化变量，以及应该如何正确初始化和更新寄存器或变量。</p><h3 id="3-其他"><a href="#3-其他" class="headerlink" title="3.其他"></a>3.其他</h3><ul><li><p><code>always @(*)</code> 组合逻辑里面不要有</p>  <figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog">i = i + <span class="hljs-number">1</span>;<br>tem = tem + a[i] * b[i];<br></code></pre></td></tr></table></figure></li></ul><p>​会多次累加，导致逻辑错误。</p><ul><li><p><code>reg</code> 类型的信号必须在 <code>always</code> 块中进行赋值，而不能通过 <code>assign</code> 语句进行驱动。</p><p>  <code>assign</code> 语句通常用于连续赋值，即用于 <code>wire</code> 类型信号，通常用于组合逻辑。而 <code>reg</code> 信号则用于存储状态，应该由 <code>always</code> 块控制。</p></li><li><p>不要<code>&#123; &#125;</code>，要用<code>begin end</code> ！！！</p></li><li><p>粘个原码</p>  <figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> dot_product (<br>    <span class="hljs-keyword">input</span>  [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] a,<br>    <span class="hljs-keyword">input</span>  [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] b,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">5</span>:<span class="hljs-number">0</span>] result<br>);<br>    <span class="hljs-keyword">integer</span> i;<br>    <span class="hljs-keyword">reg</span> [<span class="hljs-number">5</span>:<span class="hljs-number">0</span>] temp;<br><br>    <span class="hljs-keyword">always</span> @(*) <span class="hljs-keyword">begin</span><br>        temp = <span class="hljs-number">0</span>; <br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i = i + <span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span><br>            temp = temp + (a[i] * b[i]);<br>        <span class="hljs-keyword">end</span><br>        result = temp;<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br><br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>CO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于博客</title>
    <link href="/2024/07/29/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2/"/>
    <url>/2024/07/29/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="关于博客"><a href="#关于博客" class="headerlink" title="关于博客"></a>关于博客</h1><h2 id="1-一些命令"><a href="#1-一些命令" class="headerlink" title="1.一些命令"></a>1.一些命令</h2><ul><li><p>创建</p>  <figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">hexo <span class="hljs-built_in">new</span> <span class="hljs-string">&quot;name&quot;</span>  <br>hexo <span class="hljs-built_in">new</span> <span class="hljs-built_in">post</span> <span class="hljs-string">&quot;post name&quot;</span><br>hexo <span class="hljs-built_in">new</span> page <span class="hljs-string">&quot;page name&quot;</span><br>hexo <span class="hljs-built_in">new</span> draft <span class="hljs-string">&quot;draft name&quot;</span><br>hexo publish <span class="hljs-string">&quot;post name&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>清理缓存</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo cl<br></code></pre></td></tr></table></figure></li><li><p>生成静态文件</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo g<br></code></pre></td></tr></table></figure></li><li><p>本地调试</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo s<br></code></pre></td></tr></table></figure></li><li><p>部署博客</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo d<br></code></pre></td></tr></table></figure></li><li><p>一键部署</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo cl &amp;&amp; hexo g &amp;&amp; hexo d<br></code></pre></td></tr></table></figure></li></ul><h2 id="2-主题"><a href="#2-主题" class="headerlink" title="2.主题"></a>2.主题</h2><p><a href="https://hexo.fluid-dev.com/docs/start/"> Hexo Fluid 用户手册 </a></p>]]></content>
    
    
    
    <tags>
      
      <tag>blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/07/21/hello-world/"/>
    <url>/2024/07/21/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
